dojo.provide("andes.api");
dojo.require("andes.rpc");
dojo.require("andes.error");
dojo.require("andes.messages");
dojo.require("andes.timer");

(function(){
	
	var startTime = null,
	    requestInFlight = false,
	    queue = [],
	    tries = 0;
	
	var MAX_RETRIES = 5,
	RETRY_TIMEOUT = 2000; // milliseconds
	
	// AOP-style function replacement that performs before-advice
	// to add to the headers on all XHR requests. See dojox/rpc/Client.js
	(function(){
		console.info("api set headers", andes.sessionId)
		andes._originalXhr = dojo.xhr;
		dojo.xhr = function(method,args){
			var headers = args.headers = args.headers || {};
			headers["Client-Id"] = andes.sessionId;
			return andes._originalXhr.apply(dojo,arguments);
		};
	})();

	function prepRequest(req){
		// add common elements to our requests
		var tm = ((new Date()).getTime() - (startTime || (new Date()).getTime()))/1000.0;
		return dojo.mixin({ time:tm }, req || {});
	}

	function sendRequest(req){
		// send an RPC request
		var request = prepRequest(req.params);
		requestInFlight = true;
		andes.rpc[req.method](request).addCallbacks(
			function(result){
				requestInFlight = false;
				req.dfd.callback(result);
				nextRequest();
			},
			function(error){
				//requestInFlight = false;
				if(error._rpcErrorObject){
					//
					//		Error returned from server
					//		This error can be generated by changing
					//		the RPC action to open-problemo
					//
					req.dfd.errback(error);
					var mo = andes.messages.server();
					var msg = "<p>"+mo.message+"</p><div class='errMsg'>" + error.name + ": " + error.message;
					if(error._rpcErrorObject.code){
						msg += "\n(code " + error._rpcErrorObject.code + ")";
					}
					msg += "</div><div class='action'>"+mo.action+"</div>";
					andes.error({
						title: mo.title,
						message: msg,
						errorType: andes.error.OK
					});
				}else{
					//
					//		This error occurs from a timeout, due to
					//		service interuption
					//		Can be generated by changing the SMD URL
					//
					if(++tries <= MAX_RETRIES){
						setTimeout(function(){
							sendRequest(req);
						}, RETRY_TIMEOUT);
					}else{
						req.dfd.errback(error);
						console.error(error);
						var mo = andes.messages.connection(MAX_RETRIES);
						console.dir(mo)
						andes.error({
							title: mo.title,
							message: mo.message+"<div class='action'>"+mo.action+"</div>",
							dialogType: andes.error.OK
						});
					}
				}
			}
		);
	}

	function nextRequest(){
		// process the next request in the queue, if any
		if(!requestInFlight){
			var req = queue.shift();
			if(req){
				tries = 0;
				sendRequest(req);
			}
		}
	}

	function queueRequest(method, params){
		// add a request to the queue for processing when the current
		// pending request (if any) returns
		var dfd = new dojo.Deferred();
		queue.push({dfd:dfd, method:method, params:params});
		if(queue.length == 1){
			nextRequest();
		}
		return dfd;
	}

	andes.api = {
		open: function(params){
			//console.info("andes.api.open", params);
			startTime = (new Date()).getTime();
			andes.timer = new andes.timer(startTime);
			var dfd = queueRequest("open-problem", params);
			
			dfd.addCallback(function(result){
				// look for help embedded in the returned result, so we can
				// queue it up in case the user opens the Tutor pane
				andes.help.processStep(result);
			});
			return dfd;
		},

		step: function(params){
			//console.info("andes.api.step", params);
			var dfd = queueRequest("solution-step", params);
			dfd.addCallback(function(result){
				// look for help embedded in the returned result, so we can
				// queue it up in case the user opens the Tutor pane
				andes.help.processStep(result);
			});
			return dfd;
		},

		help: function(params){
			//console.info("andes.api.help", params);
			return queueRequest("seek-help", params);
		},

                suggestWord: function(params){
			//console.info("andes.api.suggestWord", params);
			var dfd = queueRequest("suggest-word", params);
			dfd.addCallback(function(result){
				andes.WordTip.processResults(result);
			});
			return dfd;
		},

                recordAction: function(params){
			// Could be implemented as a json-rpc notification;
			queueRequest("record-action", params);
		},

		close: function(params){
			console.info("andes.api.close", params);
			return queueRequest("close-problem", params);
		}
	};

})();

